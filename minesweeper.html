<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html><head><style type="text/css">body {background-color:azure;}.cell {width:50px; height:50px; background-color:grey}</style><script type="text/javascript" src="jquery-1.7.1.js"></script><script type="text/javascript">//======================= util ================================//class Enumfunction Enum(list) {	var en = new Object();	for (var i in list) {		en[list[i]] = { str : list[i], toString : function() { return this.str; } };	}	//add Object.freeze(en) here	return en;}//class FSM - finite state machinefunction FSM(initialState) {	var currentState = initialState;	this.getCurrentState = function() { return currentState; }		var transitions = new Object();		this.addTransition = function(fromState, toState, func) {		if (!transitions[fromState]) { 			transitions[fromState] = new Object(); 		}		transitions[fromState][toState] = func;	}		this.changeState = function(newState) {		var state = currentState;		currentState = newState;		var f = transitions[state][newState];		f();			}		this.debug = function() {		for (var i in transitions) {			for (var j in transitions[i]) {				alert(transitions[i][j]);			}		}	}}function visitNeighbourCells(cellsArray, x, y, callback) {	for (var i = x - 1; i <= x + 1; ++i) {		for (var j = y - 1; j <= y + 1; ++j) {			if (i == x && j == y) {				continue;			} else {				if (i >= 0 && i < cellsArray.length &&					j >= 0 && j < cellsArray[i].length) {					callback(cellsArray[i][j], i, j);				}			}		}	}}//================= end util ========================//================= sweeper =========================//class Cellfunction Cell(clicked, content, mark) {	this.clicked = clicked;	this.content = content;	this.mark = mark;}var Content = new Enum ([	'NONE', 'MINE', 'ONE', 'TWO', 'THREE', 'FOUR', 	'FIVE', 'SIX', 'SEVEN', 'EIGHT']);var State = new Enum([	'BEGIN', 'RUNNING', 'GAME_OVER', 'FINISH']); var Mark = new Enum ([	'NONE', 'FLAG', 'QUESTION']);//class Sweeperfunction Sweeper(x, y, mines, _ui) {	//_ui - user interface, must implement setSweeper(sweeper), showCells(cells) and refreshCell(cell, x, y) functions	var mines = mines;	var x = x;	var y = y;	var ui = _ui;	ui.setSweeper(this);		var cells = new Array();	this.getCells = function() { return cells; }	//generate cells	{		var minesMap = new Array();		for (var i = 0; i < x; ++i) {			minesMap.push(new Array(y));		}		var minesCount = 0;				while (minesCount < mines) {			var xm = Math.floor(Math.random() * x);			var	ym = Math.floor(Math.random() * y);			if (minesMap[xm][ym] != true) {				minesMap[xm][ym] = true;				++minesCount;			}		}				for (var i = 0; i < x; ++i) {			cells.push(new Array());			for (var j = 0; j < y; ++j) {				var content;				if (minesMap[i][j]) {					content = Content.MINE;				} else {					content = Content.NONE;				}				cells[i].push(new Cell(false, content, Mark.NONE));			}		}		//calculate mines around each cell		var contentMap = new Array();		contentMap[0] = Content.NONE;		contentMap[1] = Content.ONE;		contentMap[2] = Content.TWO;		contentMap[3] = Content.THREE;		contentMap[4] = Content.FOUR;		contentMap[5] = Content.FIVE;		contentMap[6] = Content.SIX;		contentMap[7] = Content.SEVEN;		contentMap[8] = Content.EIGHT;					for (var i = 0; i < x; ++i) {			for (var j = 0; j < y; ++j) {				if (cells[i][j].content != Content.MINE) {					var count = 0;					visitNeighbourCells(cells, i, j, 						function(cell, x, y) {							if (cell.content == Content.MINE) { 								++count;							}						});					cells[i][j].content = contentMap[count];				}			}		}		} 	//end generate cells		var stateManager = new FSM(State.BEGIN);	this.getStateManager = function() { return stateManager; }	//initialize state manager with transitions	var finishGame = function() { 		for (var i in cells) {			for (var j in cells[i]) {				ui.refreshCell(cells[i][j], i, j);				clearInterval(interval);			}		}	};	stateManager.addTransition(State.RUNNING, State.GAME_OVER, finishGame);	stateManager.addTransition(State.BEGIN, State.GAME_OVER, finishGame);	var interval;	var seconds = 0;	this.getSeconds = function() { return seconds; }	stateManager.addTransition(State.BEGIN, State.RUNNING, 		function() {			interval = setInterval(function() { ui.refreshSeconds(++seconds); }, 1000);	});	stateManager.addTransition(State.RUNNING, State.FINISH, 		function() {			alert('finish');			finishGame();			minesRemained = 0;			ui.refreshMinesRemained(minesRemained);	});			var notClickedCells = x * y;		var doClickCell = function(x, y) {		cells[x][y].clicked = true;		ui.refreshCell(cells[x][y], x, y);		--notClickedCells;		if (stateManager.getCurrentState() == State.RUNNING &&			notClickedCells === mines) {						stateManager.changeState(State.FINISH);		}	}		//click and mark cell actions		var checkClickPreconditions = function(x, y) {		if (stateManager.getCurrentState() == State.GAME_OVER ||			stateManager.getCurrentState() == State.FINISH ||			cells[x][y].clicked) {			return false;		} else {			return true;		}	}			var _clickCell = function(x, y) { //workaround to make recursive call of this function		if (!checkClickPreconditions(x, y)) {			return;		}		if (stateManager.getCurrentState() == State.BEGIN) {			stateManager.changeState(State.RUNNING);		}				var mark = cells[x][y].mark;		if (mark == Mark.FLAG) { 			return; 		}		doClickCell(x, y);				var content = cells[x][y].content;		if (content == Content.MINE) {			stateManager.changeState(State.GAME_OVER);		} else if (content == Content.NONE) {			visitNeighbourCells(cells, x, y, 				function(cell, i, j) {					if (!cell.clicked) {						_clickCell(i, j);					}				});				} 	}	this.clickCell = _clickCell;		var minesRemained = mines;	this.minesRemained = function() { return minesRemained; }		this.markCell = function(x, y) {		if (!checkClickPreconditions(x, y)) {			return;		}				var cell = cells[x][y];		switch (cell.mark) {			case Mark.NONE:				cell.mark = Mark.FLAG;				--minesRemained;				ui.refreshMinesRemained(minesRemained);				break;			case Mark.FLAG:				cell.mark = Mark.QUESTION;				++minesRemained;				ui.refreshMinesRemained(minesRemained);				break;			case Mark.QUESTION:				cell.mark = Mark.NONE;				break;			default:				throw "unknown mark " + cell.mark;		}				ui.refreshCell(cell, x, y);	}	ui.prepare(cells, minesRemained, seconds);	}//==================== end sweeper ===========================//==================== front end ========================//class UIfunction UI() {		var sweeper;	this.setSweeper = function(_sweeper) { sweeper = _sweeper; }	this.getSweeper = function() { return sweeper; }		//TODO - make next 2 functions static	this.XYToCellId = function(x, y) {		return 'r' + x + 'h' + y;	}		this.cellIdToXY = function(rh) {		return { 			x : Number(rh.match(/^r(\d+)/)[1]), 			y : Number(rh.match(/h(\d+)$/)[1])		};				}		this.prepare = function(cells, minesRemained, seconds) {		for (var i in cells) {			var row = 'r'+i;			$("#field").append('<tr id='+ row + '>');			for (var j in cells[i]) {				var id = this.XYToCellId(i, j);				var html = '<th id="' + id +'"class=\'cell\' onmousedown="onCellClick(\'' + id + '\')"></th>';				$("#"+row).append(html);				this.refreshCell(cells[i][j], i, j);			}			$("#field").append('</tr>');		}		this.refreshMinesRemained(minesRemained);		this.refreshSeconds(seconds);	}		this.refreshCell = function(cell, x, y) {		var rh = this.XYToCellId(x, y);		var state = this.getSweeper().getStateManager().getCurrentState() ;		var markFlag = function() {			$('#'+rh).html('P');			$('#'+rh).css('color', 'red');		};		var showMine = function() {			$('#'+rh).html('*');		};		var setClickedBackground = function() {			$('#'+rh).css('background-color', 'white');		};		if (!cell.clicked) {			var html = '';			switch (cell.mark) {				case Mark.FLAG: 					if (state == State.GAME_OVER && 						cell.content != Content.MINE) {	//draw cross						$('#'+rh).html('X');						$('#'+rh).css('color', 'green');					} else {						markFlag();					}					break;				case Mark.QUESTION:					$('#'+rh).html('?');					$('#'+rh).css('color', 'blue');					break;				case Mark.NONE:					if (state == State.FINISH &&						cell.content == Content.MINE) {						markFlag();					} else if (state == State.GAME_OVER &&							   cell.content == Content.MINE){						showMine();						setClickedBackground();						return;					} else {						$('#'+rh).html('');					}					break;				default: 					throw 'unknown mark ' + cell.mark;			}			$('#'+rh).css('background-color', 'grey');		} else {			switch (cell.content) {				case Content.MINE:					showMine();					$('#'+rh).css('background-color', 'red');					return;				case Content.NONE:					$('#'+rh).html('');					break;				case Content.ONE:					$('#'+rh).html('1');					$('#'+rh).css('color', 'blue');					break;				case Content.TWO:					$('#'+rh).html('2');					$('#'+rh).css('color', 'green');					break;				case Content.THREE:					$('#'+rh).html('3');					$('#'+rh).css('color', 'red');					break;				default:					$('#'+rh).html(cells[x][y].content);			}			setClickedBackground();		}	}		this.refreshMinesRemained = function(minesRemained) {		$('#mines').html('remained: ' + minesRemained + ' mines');	}	this.refreshSeconds = function(seconds) {		$('#seconds').html('elapsed: ' + seconds + ' seconds');	}}//=================== end front end =================var onCellClick = null;$(document).ready(function(){	var ui = new UI();	var sweeper = new Sweeper(10, 10, 5, ui);			onCellClick = function(rh) {		var xy = ui.cellIdToXY(rh);		if (event.which == 1) { //left click			sweeper.clickCell(xy.x, xy.y);		} else if (event.which == 3) { //right click			sweeper.markCell(xy.x, xy.y);		}	}});</script></head><body><p id="seconds"></p><div oncontextmenu='return false'>	<table id="field">	</table>	</div><p id="mines"></p>		</body></html>